{"meta":{"title":"CallMe_star","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/callme-star.github.io/"},"pages":[{"title":"所有分类","date":"2020-08-16T15:23:21.601Z","updated":"2020-08-15T13:51:09.258Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About Me. || 关于我","date":"2020-08-17T01:55:08.346Z","updated":"2020-08-17T01:55:08.337Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"本人技术小白一个，刚刚入坑，望大家多指教。 搭建博客的目的就是为了有个自己的独立空间，记点学习笔记，记录自己的成长历程。 在接下来的时间里面我会慢慢更新一些java相关的学习经历，和后续的成果。 因为接下来主要学习图像处理和深度学习的相关内容，所以博客主旋律是图像和机器学习。 还请大佬们多多指教 123456#include&lt;iostream&gt;using nemespace std;int main&#123; cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;&quot;\\n&quot;&lt;&lt;&quot;Hello every one!&quot;&#125; Hello world! Hello every one! Contact Me qq: 1024422413"},{"title":"帮助过我的大佬们","date":"2020-08-16T15:23:12.282Z","updated":"2020-08-15T15:06:29.119Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-08-15T14:47:15.248Z","updated":"2020-08-15T14:47:15.240Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习java第一天——语言类型","slug":"学习java第一天——语言类型","date":"2020-08-13T04:12:12.000Z","updated":"2020-08-15T15:21:44.582Z","comments":true,"path":"2020/08/13/学习java第一天——语言类型/","link":"","permalink":"http://yoursite.com/2020/08/13/%E5%AD%A6%E4%B9%A0java%E7%AC%AC%E4%B8%80%E5%A4%A9%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/","excerpt":"解释型语言解释型语言的典型：python、JavaScript、Ruby等。","text":"解释型语言解释型语言的典型：python、JavaScript、Ruby等。 解释型语言的特点，我理解的就是解释一句跑一句子，如果下边语句有错误，并不会影响上边语句的执行。要想写小的程序，基本上可以忽略执行效率的基础上，还想让程序能成功跑下去，解释型语言还是很香的。 编译型语言编译型语言的典型：C和C++等 汇编型语言的特点，我理解的就是把所有语句都从头理一遍，如果其中出现一句语句有错误，整个程序都无法运行。所以要想提高程序的执行效率，要想写大工程文件，还是要转换成编译型语言的。 编译型—解释型语言典型代表:Java 严格地说，Java其实就是解释型语言，其所谓的编译过程只是将.java文件编程成.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别；然后生成的.class文件再逐句进行解释，在Java的虚拟机JVM中运行。在现实中，java开发工具JDK提供了两个很重要的命令来完成上面的编译和解释（翻译）过程：javac.exe是将.java文件编译成.class文件，而java.exe是将.class文件解释执行吧 总结解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。 当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。 但随着硬件的升级和设计思想的变革，编译型和解释型语言越来越笼统，主要体现在一些新兴的高级语言上，而解释型语言的自身特点也使得编译器厂商愿意花费更多成本来优化解释器，解释型语言性能超过编译型语言也是必然的。","categories":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/categories/java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/tags/java%E7%AC%94%E8%AE%B0/"}]},{"title":"傅里叶变换","slug":"图像处理——傅里叶变换","date":"2020-08-13T04:12:12.000Z","updated":"2020-08-15T15:21:42.469Z","comments":true,"path":"2020/08/13/图像处理——傅里叶变换/","link":"","permalink":"http://yoursite.com/2020/08/13/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/","excerpt":"1.傅里叶变换的理解傅里叶变换的相关数学公式目前还没有搞懂，先不整那个东西，我们主要是研究傅里叶变换的一些思想和应用。这个思想起源于牛顿研究那个三棱镜，白光透过棱镜之后会被分解为七种颜色的光，这些光叠加又能形成白光，所以说可以把一种事物分解成好几种事物的加和。","text":"1.傅里叶变换的理解傅里叶变换的相关数学公式目前还没有搞懂，先不整那个东西，我们主要是研究傅里叶变换的一些思想和应用。这个思想起源于牛顿研究那个三棱镜，白光透过棱镜之后会被分解为七种颜色的光，这些光叠加又能形成白光，所以说可以把一种事物分解成好几种事物的加和。 后来傅里叶就提出了**傅里叶级数**，一个等幅度不同频或者等频不同幅的波形可以由一组正弦波余弦波的加和得到（原话：任何连续周期信号可以由一组适当的正弦曲线组合而成） 2.傅里叶级数可以这么理解：原图像相当于在时间域中的一个曲线，坐标图是个二维坐标系，横轴是时间，纵轴是幅值的一个曲线，我们通过傅里叶变换可以把这条曲线变成多条正余弦函数相加的形式：傅里叶变换之后形成的是一个三维坐标系，他的x轴是频率（w），y轴是相位（因为每个正余弦函数的起点不同，有的是从零点开始，有的不是，这个曲线开始的那个幅值就是相位，相位就是后公式中的φ），z轴是振幅高度，。这样可以把一个图像从空间域转换到频率域，因为两者等价，所以可以逆变换回去。但这个傅里叶级数只能针对周期型函数才能拆分成多个正余弦函数相加，所以后来有了傅里叶变换。$$f(t) = \\frac{a_n}{2}+\\sum a_n*sin（nwt+φ_n）$$ 3.傅里叶变换其中推导公式中用到了欧拉公式，$$cos(x)+i*sin(x) = e^{ix}\\$$$$x = wt$$ $$F_T = \\int_{-\\infty}^{+\\infty}f(t)e^{jwt}dt\\$$ 然后通过逆变换可以再变回去。通过傅里叶变换就可以把一个随机的曲线，转换到频率域，只不过这次的三维坐标系对应的w和幅值的函数图像不再是离散的图像了，而是一个连续图像。y轴所对应的相位意义没变。 4.应用- 声音通过分析频率域，可以分析出低频可能是男生说话，高频可能是女生说话，再高的频率就是噪音了，除去这些高频信号，然后通过逆变换就可以得到处理后的音频。 在声音中，那刚才的傅里叶变换之前的x轴就是时间，y轴就是声音的振幅 如下图（copy from 知乎Heinrich） - 图像通过分析频率域，他的低频部分可能就是画像的主体部分，高频部分可能是图像中的噪点，比如说是画面中的斑点噪音，旧照片中的斑点，通过去掉高频信号，然后逆变换回去，就得到去除噪点之后的图像。 在图像中，傅里叶变换之前的x轴就是图像的空间坐标位置，y轴就是他的灰度？？？ 5.OpenCV ，Numpy中的操作一下-numpy中操作 np.fft.fft2 实现傅里叶变换并且返回一个复数数组 np.fft.fftshift 将零频率分量移动到频谱的中心 np.log（np.abs(fshift)） 刚才返回的复数数组没办法用图像的形式展示出来需要用以上函数转换到[0, 255]范围 np.fft.ifftshift 把中心化的频谱再移动回左上角 np.fft.ifft2 实现逆变换，返回一个复数数组 np.abs（逆傅里叶变换的结果） ​ 变回能显示的[0, 255]的可显示图像 1234567891011121314151617181920212223import cv2import numpy as npimport matplotlib.pyplot as plt# 直接读为灰度图像img = cv2.imread(&#x27;你电脑本地的图像路径&#x27;, 0) f = np.fft.fft2(img)fshift = np.fft.fftshift(f)# 取绝对值：将复数变化成实数# 取对数的目的为了将数据变化到0-255s1 = np.log(np.abs(fshift))plt.subplot(131), plt.imshow(img, cmap=&#x27;gray&#x27;, interpolation=&#x27;bicubic&#x27;), plt.title(&#x27;original&#x27;)plt.xticks([]), plt.yticks([])plt.subplot(132), plt.imshow(s1, &#x27;gray&#x27;, interpolation=&#x27;bicubic&#x27;), plt.title(&#x27;center&#x27;)plt.xticks([]), plt.yticks([])# 逆变换f1shift = np.fft.ifftshift(fshift)img_back = np.fft.ifft2(f1shift)# 出来的是复数，无法显示img_back = np.abs(img_back)plt.subplot(133), plt.imshow(img_back, cmap=&#x27;gray&#x27;, interpolation=&#x27;bicubic&#x27;), plt.title(&#x27;img back&#x27;)plt.xticks([]), plt.yticks([])plt.show() OpenCV中操作 返回结果 = cv2.dft(原始图像， 转换标识) 返回结果是双通道的，第一通道是结果的实数部分，第二通道是虚数部分 原始图像一般是整型八位位图，要转换成32位的（np.float32(img)） 转换标识一般flags = cv2.DFT_COMPLEX_OUTPUT,输出一个复数阵列 np.fft.fftshift 将零频率分量转换频谱中心 返回值 = cv2.magnitude（参数1，参数2） 参数1：浮点的X坐标，也就是实部 参数2：浮点的Y坐标，也就是虚部 通过这个函数，将那个复数转换到[0, 255] 12345678910111213141516171819202122import cv2import numpy as npimport matplotlib.pyplot as pltimg = cv2.imread(&#x27;电脑本地的图像地址&#x27;， 0)dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)dftshift = np.fft.fftshift(dft)result = 20*np.log(cv2.magnitude(dftshift[:,:,0], dftshift[:,:,1]))ishift = np.fft.ifftshift(dftshift)iimg = cv2.idft(ishift)iimg = cv2.magnitude(iimg[:, :, 0], iimg[:, :, 1])plt.subplot(221), plt.imshow(img,&#x27;gray&#x27;)plt.title(&#x27;img&#x27;), plt.axis(&#x27;off&#x27;)plt.subplot(222), plt.imshow(result,&#x27;gray&#x27;)plt.title(&#x27;result&#x27;), plt.axis(&#x27;off&#x27;)plt.subplot(223), plt.imshow(img, &#x27;gray&#x27;)plt.title(&#x27;img&#x27;), plt.axis(&#x27;off&#x27;)plt.subplot(224), plt.imshow(iimg, &#x27;gray&#x27;)plt.title(&#x27;result&#x27;), plt.axis(&#x27;off&#x27;)plt.show() 低通滤波1234567891011121314151617181920import cv2import numpy as npimport matplotlib.pyplot as pltimg = cv2.imread(&#x27;/Users/star/learning_python/picture/2.png&#x27;, 0)dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)dshift = np.fft.fftshift(dft)rows, cols = img.shaperow, col = int(rows/2), int(cols/2)mask = np.zeros((rows, cols, 2), np.uint8)mask[row-50:row+50, col-50:col+50] = 1dst = dshift * maskidst = np.fft.ifftshift(dst)ishift = cv2.idft(idst)idst = cv2.magnitude(ishift[:, :, 0], ishift[:, :, 1])plt.subplot(121), plt.imshow(img, &#x27;gray&#x27;)plt.title(&#x27;img&#x27;), plt.axis(&#x27;off&#x27;)plt.subplot(122), plt.imshow(idst, &#x27;gray&#x27;)plt.title(&#x27;img&#x27;), plt.axis(&#x27;off&#x27;)plt.show() 高通滤波123456789101112131415161718import cv2import numpy as npimport matplotlib.pyplot as pltimg = cv2.imread(&#x27;电脑本地的图像地址&#x27;， 0)f = np.fft.fft2(img)fshift = np.fft.fftshift(f) rows,cols = img.shape[:2]crow,ccol = int(rows/2), int(cols/2)fshift[crow-30:crow+30, ccol-30:ccol+30] = 0ishift = np.fft.ifftshift(fshift)iimg = np.fft.ifft2(ishift)iimg = np.abs(iimg)plt.subplot(121),plt.imshow(img, &#x27;gray&#x27;)plt.title(&#x27;img&#x27;),plt.axis(&#x27;off&#x27;)plt.subplot(122),plt.imshow(iimg, &#x27;gray&#x27;)plt.title(&#x27;iimg&#x27;),plt.axis(&#x27;off&#x27;)plt.show()","categories":[{"name":"图像处理笔记","slug":"图像处理笔记","permalink":"http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图像处理笔记","slug":"图像处理笔记","permalink":"http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/categories/java%E7%AC%94%E8%AE%B0/"},{"name":"图像处理笔记","slug":"图像处理笔记","permalink":"http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/tags/java%E7%AC%94%E8%AE%B0/"},{"name":"图像处理笔记","slug":"图像处理笔记","permalink":"http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"}]}