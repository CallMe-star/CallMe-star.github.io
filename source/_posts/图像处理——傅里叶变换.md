---
title: 傅里叶变换
data: 2020-08-13 12:12:12
body: [article, comments]
meta: 
  header: [title, author, date,category]
  footer: [updated, tags, share]
categories: 图像处理笔记
tags: 图像处理笔记
mathjax: true
---

> 图像处理——傅里叶

<!--more-->

### 1.傅里叶变换的理解

傅里叶变换的相关数学公式目前还没有搞懂，先不整那个东西，我们主要是研究傅里叶变换的一些思想和应用。这个思想起源于牛顿研究那个三棱镜，白光透过棱镜之后会被分解为七种颜色的光，这些光叠加又能形成白光，所以说可以把一种事物分解成好几种事物的加和。

后来傅里叶就提出了***傅里叶级数***，一个等幅度不同频或者等频不同幅的波形可以由一组正弦波余弦波的加和得到（原话：任何连续周期信号可以由一组适当的正弦曲线组合而成）

### 2.傅里叶级数

可以这么理解：原图像相当于在时间域中的一个曲线，坐标图是个二维坐标系，横轴是时间，纵轴是幅值的一个曲线，我们通过傅里叶变换可以把这条曲线变成多条正余弦函数相加的形式：傅里叶变换之后形成的是一个三维坐标系，他的x轴是频率（w），y轴是相位（因为每个正余弦函数的起点不同，有的是从零点开始，有的不是，这个曲线开始的那个幅值就是相位，相位就是后公式中的φ），z轴是振幅高度，。这样可以把一个图像从空间域转换到频率域，因为两者等价，所以可以逆变换回去。但这个傅里叶级数只能针对周期型函数才能拆分成多个正余弦函数相加，所以后来有了傅里叶变换。
$$
f(t) = \frac{a_n}{2}+\sum a_n*sin（nwt+φ_n）
$$

### 3.傅里叶变换

其中推导公式中用到了欧拉公式，
$$
cos(x)+i*sin(x) = e^{ix}\\
$$
$$
x = wt
$$

$$
F_T = \int_{-\infty}^{+\infty}f(t)e^{jwt}dt\\
$$





然后通过逆变换可以再变回去。通过傅里叶变换就可以把一个随机的曲线，转换到频率域，只不过这次的三维坐标系对应的w和幅值的函数图像不再是离散的图像了，而是一个连续图像。y轴所对应的相位意义没变。

### 4.应用

#### - 声音

通过分析频率域，可以分析出低频可能是男生说话，高频可能是女生说话，再高的频率就是噪音了，除去这些高频信号，然后通过逆变换就可以得到处理后的音频。

在声音中，那刚才的傅里叶变换之前的x轴就是时间，y轴就是声音的振幅

如下图（copy from 知乎Heinrich）

![](https://cdn.jsdelivr.net/gh/CallMe-star/picbed@master/fuliye1.jpg)

#### - 图像

通过分析频率域，他的低频部分可能就是画像的主体部分，高频部分可能是图像中的噪点，比如说是画面中的斑点噪音，旧照片中的斑点，通过去掉高频信号，然后逆变换回去，就得到去除噪点之后的图像。

在图像中，傅里叶变换之前的x轴就是图像的空间坐标位置，y轴就是他的灰度？？？

### 5.OpenCV ，Numpy中操作一下

#### -numpy中操作

1. np.fft.fft2

   实现傅里叶变换并且返回一个复数数组

2. np.fft.fftshift

   将零频率分量移动到频谱的中心

3. np.log（np.abs(fshift)）

   刚才返回的复数数组没办法用图像的形式展示出来需要用以上函数转换到[0, 255]范围

4. np.fft.ifftshift

   把中心化的频谱再移动回左上角

5. np.fft.ifft2

   实现逆变换，返回一个复数数组

6. np.abs（逆傅里叶变换的结果）

​		变回能显示的[0, 255]的可显示图像

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 直接读为灰度图像
img = cv2.imread('你电脑本地的图像路径', 0)  
f = np.fft.fft2(img)
fshift = np.fft.fftshift(f)
# 取绝对值：将复数变化成实数
# 取对数的目的为了将数据变化到0-255
s1 = np.log(np.abs(fshift))
plt.subplot(131), plt.imshow(img, cmap='gray', interpolation='bicubic'), plt.title('original')
plt.xticks([]), plt.yticks([])
plt.subplot(132), plt.imshow(s1, 'gray', interpolation='bicubic'), plt.title('center')
plt.xticks([]), plt.yticks([])
# 逆变换
f1shift = np.fft.ifftshift(fshift)
img_back = np.fft.ifft2(f1shift)
# 出来的是复数，无法显示
img_back = np.abs(img_back)
plt.subplot(133), plt.imshow(img_back, cmap='gray', interpolation='bicubic'), plt.title('img back')
plt.xticks([]), plt.yticks([])
plt.show()
```



#### OpenCV中操作

1. 返回结果 = cv2.dft(原始图像， 转换标识)

   返回结果是双通道的，第一通道是结果的实数部分，第二通道是虚数部分

   原始图像一般是整型八位位图，要转换成32位的（np.float32(img)）

   转换标识一般flags = cv2.DFT_COMPLEX_OUTPUT,输出一个复数阵列

2. np.fft.fftshift

   将零频率分量转换频谱中心

3. 返回值 =  cv2.magnitude（参数1，参数2）

   参数1：浮点的X坐标，也就是实部

   参数2：浮点的Y坐标，也就是虚部

   通过这个函数，将那个复数转换到[0, 255]

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('电脑本地的图像地址'， 0)
dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)
dftshift = np.fft.fftshift(dft)
result = 20*np.log(cv2.magnitude(dftshift[:,:,0], dftshift[:,:,1]))
ishift = np.fft.ifftshift(dftshift)
iimg = cv2.idft(ishift)
iimg = cv2.magnitude(iimg[:, :, 0], iimg[:, :, 1])
plt.subplot(221), plt.imshow(img,'gray')
plt.title('img'), plt.axis('off')
plt.subplot(222), plt.imshow(result,'gray')
plt.title('result'), plt.axis('off')
plt.subplot(223), plt.imshow(img, 'gray')
plt.title('img'), plt.axis('off')
plt.subplot(224), plt.imshow(iimg, 'gray')
plt.title('result'), plt.axis('off')
plt.show()


```

#### 低通滤波

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('/Users/star/learning_python/picture/2.png', 0)
dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)
dshift = np.fft.fftshift(dft)
rows, cols = img.shape
row, col = int(rows/2), int(cols/2)
mask = np.zeros((rows, cols, 2), np.uint8)
mask[row-50:row+50, col-50:col+50] = 1
dst = dshift * mask
idst = np.fft.ifftshift(dst)
ishift = cv2.idft(idst)
idst = cv2.magnitude(ishift[:, :, 0], ishift[:, :, 1])
plt.subplot(121), plt.imshow(img, 'gray')
plt.title('img'), plt.axis('off')
plt.subplot(122), plt.imshow(idst, 'gray')
plt.title('img'), plt.axis('off')
plt.show()
```



#### 高通滤波

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('电脑本地的图像地址'， 0)
f = np.fft.fft2(img)
fshift = np.fft.fftshift(f)		
rows,cols = img.shape[:2]
crow,ccol = int(rows/2), int(cols/2)
fshift[crow-30:crow+30, ccol-30:ccol+30] = 0
ishift = np.fft.ifftshift(fshift)
iimg = np.fft.ifft2(ishift)
iimg = np.abs(iimg)
plt.subplot(121),plt.imshow(img, 'gray')
plt.title('img'),plt.axis('off')
plt.subplot(122),plt.imshow(iimg, 'gray')
plt.title('iimg'),plt.axis('off')
plt.show()
```



